# -*- coding: utf-8 -*-
"""sol-Problem2-unweightedDisjktra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IFcOUxxAVTrxCFt2Xl94Gf_SNNEZVVxd

#Problem 2 - Grafos

Sea Graph la implementación de un grafo dirigido no ponderado. Implementa una funcion, minimumPath, que reciba dos vértices start y end, y devuelve la lista que represente el camino mínimo entre start y end. Si start o end no existen, la función devuelve la lista vacía []. 

Por ejemplo, dado el grafo: 

<img src='https://miro.medium.com/max/4000/1*Fi1AZPZLrGf-6wM_wTSPQw.png' width='50%'>

- minimumPath(A,A)=[]
- minimumPath(A,B)=[A,B]
- minimumPath(A,C)=[A,B,C]
- minimumPath(A,D)=[A,B,D]
- minimumPath(A,E)=[A,B,E]
- minimumPath(A,F)=[A,B,E,F]
- minimumPath(A,G)=[]

<BR>

- minimumPath(B,A)=[]
- minimumPath(B,B)=[]
- minimumPath(B,C)=[B,C]
- minimumPath(B,D)=[B,D]
- minimumPath(B,E)=[B,E]
- minimumPath(B,F)=[B,E,F]
- minimumPath(B,G)=[]
<BR>

- minimumPath(C,A)=[]
- minimumPath(C,B)=[]
- minimumPath(C,C)=[]
- minimumPath(C,D)=[]
- minimumPath(C,E)=[C,E]
- minimumPath(C,F)=[C,E,F]
- minimumPath(C,G)=[]
<BR>

- minimumPath(D,A)=[]
- minimumPath(D,B)=[]
- minimumPath(D,C)=[]
- minimumPath(D,D)=[]
- minimumPath(D,E)=[D,E]
- minimumPath(D,F)=[D,E,F]
- minimumPath(D,G)=[]
<BR>

- minimumPath(E,A)=[]
- minimumPath(E,B)=[]
- minimumPath(E,C)=[]
- minimumPath(E,D)=[]
- minimumPath(E,E)=[]
- minimumPath(E,F)=[E,F]
- minimumPath(E,G)=[]
<BR>

- minimumPath(F,A)=[]
- minimumPath(F,B)=[]
- minimumPath(F,C)=[]
- minimumPath(F,D)=[]
- minimumPath(F,E)=[]
- minimumPath(F,F)=[E,F]
- minimumPath(F,G)=[]
<BR>

- minimumPath(G,A)=[]
- minimumPath(G,B)=[]
- minimumPath(G,C)=[]
- minimumPath(G,D)=[G,D]
- minimumPath(G,E)=[G,D,E]
- minimumPath(G,F)=[G,D,E,F]
- minimumPath(G,G)=[]
"""

import sys
class Graph():
    def __init__(self,labels):
        """uses a dictionary to represent the graph"""
        self.vertices={}
        for v in labels:
            self.vertices[v]=[]
       
    def addEdge(self, start, end):
        """adds an edge from start to end"""
        if start not in self.vertices.keys():
            return
        if end not in self.vertices.keys():
            return
        self.vertices[start].append(end)

    def minDistance(self, distances, visited): 
        """This functions returns the vertex (index) with the mininum distance. We 
        only consider the set of vertices that have not been visited"""
        # Initilaize minimum distance for next node 
        min = sys.maxsize 

        #returns the vertex with minimum distance from the non-visited vertices
        for i in self.vertices: 
            if distances[i] <= min and visited[i] == False: 
                min = distances[i] 
                min_index = i 
    
        return min_index 

    def dijkstra(self, origin): 
        """"This function takes a vertex v and calculates its mininum path 
        to the rest of vertices by using the Dijkstra algoritm"""  
        
        #we use a Python list of boolean to save those nodes that have already been visited  
        # Mark all the vertices as not visited 
        visited={}
        for v in self.vertices.keys():
            visited[v]=False

        #this list will save the previous vertex 
        previous={}
        for v in self.vertices.keys():
            previous[v]=-1

        #This array will save the accumulate distance from v to each node
        distances={}
        for v in self.vertices.keys():
            distances[v]=sys.maxsize

        #The distance from v to itself is 0
        distances[origin] = 0
        
        for n in range(len(self.vertices)): 
            # Pick the vertex with the minimum distance vertex.
            # u is always equal to v in first iteration 
            u = self.minDistance(distances, visited) 
            # Put the minimum distance vertex in the shotest path tree
            visited[u] = True
            
            # Update distance value of the u's adjacent vertices only if the current  
            # distance is greater than new distance and the vertex in not in the shotest path tree 
            for i in self.vertices[u]:
                if visited[i]==False and distances[i]>distances[u]+1:
                    distances[i]=distances[u]+1   
                    previous[i]=u       
                
        #finally, we print the minimum path from v to the other vertices

        #self.printSolution(distances,previous,origin)
        return distances,previous

    def minimumPath(self,start,end): 
        """returns a list containing the minimum path from start to end"""
        distances,previous=self.dijkstra(start)
        minimum_path=[]
        if start==end:
            #print('start == end ')
            pass
        elif distances[end]==sys.maxsize:
            #print("There is not path from ",start,' to ',end)
            pass
        else: 
            prev=previous[end]
            while prev!=-1:
                minimum_path.insert(0,prev)
                prev=previous[prev]
                
            minimum_path.append(end)  

        return minimum_path

"""<img src='https://miro.medium.com/max/4000/1*Fi1AZPZLrGf-6wM_wTSPQw.png' width='50%'>

labels=['A', 'B', 'C', 'D', 'E','F','G']    

g = Graph(labels)  
g.addEdge('A', 'B')
g.addEdge('B', 'C')
g.addEdge('B', 'D')
g.addEdge('B', 'E')
g.addEdge('C', 'E')
g.addEdge('D', 'E')
g.addEdge('E', 'F')
g.addEdge('G', 'D')

print('minimum paths from A:')

print(g.minimumPath('A','A')) #[]
print(g.minimumPath('A','B')) #['A', 'B']
print(g.minimumPath('A','C')) # ['A', 'B', 'C']
print(g.minimumPath('A','D'))  #['A', 'B', 'D']
print(g.minimumPath('A','E'))   #['A', 'B', 'E']
print(g.minimumPath('A','F'))   #['A', 'B', 'E', 'F']
print(g.minimumPath('A','G'))   #[]

print('minimum paths from G:')
print(g.minimumPath('G','A')) #[]
print(g.minimumPath('G','B')) #[]
print(g.minimumPath('G','C')) # []
print(g.minimumPath('G','D'))  #[G,D]
print(g.minimumPath('G','E'))   #[G,D,E]
print(g.minimumPath('G','F'))   #[G,D,E,F]
print(g.minimumPath('G','G'))   #[]
"""

import unittest

class Test(unittest.TestCase):
    #save mark
    mark=0
    
    def setUp(self):
        labels=['A', 'B', 'C', 'D', 'E','F','G']    
        # Create a given graph  
        self.g = Graph(labels)  
        self.g.addEdge('A', 'B')
        self.g.addEdge('B', 'C')
        self.g.addEdge('B', 'D')
        self.g.addEdge('B', 'E')
        self.g.addEdge('C', 'E')
        self.g.addEdge('D', 'E')
        self.g.addEdge('E', 'F')
        self.g.addEdge('G', 'D')

    def test_printMark(self):
        print('\n\n*************************')
        print("\n Provisional mark:",Test.mark)  
        print('*************************')

    def test1_minimumPath(self):
        print('Case 1: start==end ')
        self.assertEqual(self.g.minimumPath('A','A'), [])
        print('\t\t mark += 2')
        Test.mark+=2
        print()
    
    def test2_minimumPath(self):
        print('Case 2: No path ')
        self.assertEqual(self.g.minimumPath('A','G'), [])
        print('\t\t mark += 2')
        Test.mark+=2
        print()

    def test3_minimumPath(self):
        
        print('Case 3: path with distance 1')
        result=self.g.minimumPath('A','B')
        expected=['A','B']
        print('result:',result)
        print('expected:',expected)
        
        self.assertListEqual(result, expected)
        print('\t\t mark += 4')
        Test.mark+=4
        print()

    def test4_minimumPath(self):
        
        print('Case 4: path with distance 2')
        result=self.g.minimumPath('A','C')
        expected=['A','B','C']
        print('result:',result)
        print('expected:',expected)
        
        self.assertListEqual(result, expected)
        print('\t\t mark += 6')
        Test.mark+=6
        print()

    def test5_minimumPath(self):
        
        print('Case 4: path with distance 4')
        result=self.g.minimumPath('A','F')
        expected=['A', 'B', 'E', 'F']
        print('result:',result)
        print('expected:',expected)
        
        self.assertListEqual(result, expected)
        print('\t\t mark += 6')
        Test.mark+=6
        print()

 

#Google colab
unittest.main(argv=['first-arg-is-ignored'], exit=False)

# Spyder
#if __name__ == '__main__': 
#    unittest.main()